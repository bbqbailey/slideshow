#!/usr/bin/env python3
# Slideshow-V2-1.py - Version V2-1
#
# Base: V1-0 (MJPEG push, recursive directory walking via collect_image_directories)
#
# V2-0 additions:
# - Uses radar.weather.gov ridge static GIFs as extra frames
# - Fixed cycle (no time-based N logic):
#       Show IMAGE_COUNT_DISPLAY photos
#       then TIME
#       then RADAR 1
#       then RADAR 2
#   and repeat.
#
# V2-1 additions:
# - Adds a WEATHER frame using weather_panel.png generated by weather_panel_v0-1.py
# - New cycle:
#       12 photo images
#       -> TIME
#       -> WEATHER
#       -> RADAR 1
#       -> RADAR 2
#   and repeat.
#
# Latest revision:
# - SLIDE_DURATION_SECONDS = 8
# - IMAGE_COUNT_DISPLAY = 12
# - Sequence (per cycle of 16 frames):
#       12 photo images  ->  TIME  ->  WEATHER  ->  RADAR1  ->  RADAR2
# - Restored V1-0 semantics for:
#       * placeholder color (50, 0, 0)
#       * "SKIPPED: {basename}" text on image error
#       * MJPEG disconnect log message text

import ssl
import os
import time
import random
import logging
import logging.handlers
import argparse
import threading
from http.server import SimpleHTTPRequestHandler, HTTPServer
from socketserver import ThreadingMixIn
from io import BytesIO

import requests
from PIL import Image, ImageDraw, ImageFont, ExifTags

# --- SLIDESHOW CONFIGURATION ---
IMAGES_PER_DIRECTORY = 50
SLIDE_DURATION_SECONDS = 8          # per-frame display time (photos + non-photos)
IMAGE_COUNT_DISPLAY = 12            # number of photo images before TIME + WEATHER + RADAR1 + RADAR2

IMAGE_EXTENSIONS = ('.jpg', '.jpeg', '.png', '.gif')

# radar.weather.gov ridge GIFs (latest frame)
RADAR_IMAGE_URLS = [
    "https://radar.weather.gov/ridge/standard/CONUS-LARGE_0.gif",
    "https://radar.weather.gov/ridge/standard/KFFC_0.gif",
]

# --- PROJECT DIRECTORY ---
PROJECT_DIR = os.path.expanduser('~/myProjects/python/slideshow')

# Weather panel PNG generated by weather_panel_v0-1.py
WEATHER_PANEL_FILENAME = "weather_panel.png"
WEATHER_PANEL_PATH = os.path.join(PROJECT_DIR, WEATHER_PANEL_FILENAME)

# --- LOGGING SETUP (same pattern as V1-0) ---
GENERAL_LOG = os.path.join(PROJECT_DIR, 'slideshow.log')
general_handler = logging.handlers.TimedRotatingFileHandler(
    GENERAL_LOG, when='midnight', interval=1, backupCount=1, encoding='utf-8'
)
general_handler.setLevel(logging.WARNING)
general_handler.setFormatter(
    logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
)

DISPLAY_LOG = os.path.join(PROJECT_DIR, 'slideshow-display.log')
display_handler = logging.handlers.TimedRotatingFileHandler(
    DISPLAY_LOG, when='midnight', interval=1, backupCount=1, encoding='utf-8'
)
display_handler.setLevel(logging.INFO)
display_handler.setFormatter(
    logging.Formatter('%(asctime)s - %(message)s')
)

display_logger = logging.getLogger('display')
display_logger.setLevel(logging.INFO)
display_logger.propagate = False
display_logger.addHandler(display_handler)
display_logger.info("=== DISPLAY LOG STARTED (V2-1 MJPEG + RADAR + WEATHER) ===")

stream_handler = logging.StreamHandler()
stream_handler.setLevel(logging.DEBUG)
stream_handler.setFormatter(
    logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
)

root_logger = logging.getLogger()
root_logger.setLevel(logging.DEBUG)
root_logger.handlers.clear()
root_logger.addHandler(general_handler)
root_logger.addHandler(stream_handler)


def log_image_display(label: str):
    display_logger.info(label)


# ======================================================================
#  RECURSIVE DIRECTORY WALKER (same behavior as V1-0)
# ======================================================================
def collect_image_directories(starting_dirs):
    """
    starting_dirs: roots from slideshowDirectories.txt or slideshowPreferred*.txt
    - Walks recursively
    - Skips any directory named exactly 'slideshow_exclude'
    - Collects all directories that contain at least one image file.
    """
    collected = []

    for start in starting_dirs:
        if not os.path.isdir(start):
            logging.warning(f"Invalid directory in slideshowDirectories.txt: {start}")
            continue

        for root, dirs, files in os.walk(start):
            # Remove any child dirs named exactly "slideshow_exclude"
            dirs[:] = [d for d in dirs if d != 'slideshow_exclude']
            # Root itself might be slideshow_exclude (if someone put it in manually)
            if os.path.basename(root) == 'slideshow_exclude':
                continue

            if any(f.lower().endswith(IMAGE_EXTENSIONS) for f in files):
                collected.append(root)

    logging.info(f"Collected {len(collected)} image directories from recursive walk")
    return collected


# ======================================================================
#  GLOBAL FRAME STATE FOR MJPEG PUSH (unchanged)
# ======================================================================
current_frame_bytes = None
current_frame_id = 0
frame_lock = threading.Lock()
frame_condition = threading.Condition(frame_lock)


def update_current_frame(frame_bytes: bytes, label: str):
    """
    Update global frame and notify all MJPEG clients.
    """
    global current_frame_bytes, current_frame_id
    with frame_condition:
        current_frame_bytes = frame_bytes
        current_frame_id += 1
        frame_condition.notify_all()

    log_image_display(label)
    logging.info(f"Updated frame_id={current_frame_id} label={label}")


# ======================================================================
#  IMAGE GENERATION HELPERS
# ======================================================================
def make_placeholder_image(text: str) -> bytes:
    # Restore V1-0 background color (50, 0, 0)
    img = Image.new('RGB', (1920, 1080), (50, 0, 0))
    draw = ImageDraw.Draw(img)
    font = ImageFont.load_default()
    draw.text((50, 50), text, fill=(255, 255, 255), font=font)
    buf = BytesIO()
    img.save(buf, format='JPEG', quality=85)
    return buf.getvalue()


def generate_time_frame() -> bytes:
    current_time = time.strftime("%I:%M").lstrip("0")
    logging.info(f"Generating time frame: {current_time}")

    img = Image.new('RGB', (1920, 1080), (0, 0, 0))
    draw = ImageDraw.Draw(img)

    font_path = "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf"
    try:
        font = ImageFont.truetype(font_path, 300)
    except IOError:
        font = ImageFont.load_default()

    try:
        bbox = draw.textbbox((0, 0), current_time, font=font)
        w, h = bbox[2] - bbox[0], bbox[3] - bbox[1]
    except AttributeError:
        w, h = draw.textsize(current_time, font=font)

    draw.text(((1920 - w) // 2, (1080 - h) // 2),
              current_time, font=font, fill=(255, 255, 255))

    buf = BytesIO()
    img.save(buf, format='JPEG', quality=95)
    return buf.getvalue()


def image_path_to_jpeg_bytes(image_path: str) -> bytes:
    """
    Load from disk, fix EXIF orientation, convert to RGB JPEG.
    """
    try:
        logging.info(f"Serving image: {image_path}")
        img = Image.open(image_path)
        img.verify()
        img = Image.open(image_path)

        # EXIF rotation fix
        try:
            orientation_tag = None
            for o in ExifTags.TAGS:
                if ExifTags.TAGS[o] == 'Orientation':
                    orientation_tag = o
                    break
            exif = img._getexif()
            if exif and orientation_tag is not None:
                orient = dict(exif.items()).get(orientation_tag, 1)
                if orient == 3:
                    img = img.rotate(180, expand=True)
                elif orient == 6:
                    img = img.rotate(270, expand=True)
                elif orient == 8:
                    img = img.rotate(90, expand=True)
        except Exception as e:
            logging.warning(f"EXIF error: {e}")

        img = img.convert("RGB")
        buf = BytesIO()
        img.save(buf, format='JPEG', quality=95)
        return buf.getvalue()

    except Exception as e:
        logging.error(f"SKIP: {image_path} | {e}")
        # Restore V1-0 placeholder text with basename
        return make_placeholder_image(f"SKIPPED: {os.path.basename(image_path)}")


def fetch_radar_frame(url: str) -> bytes:
    """
    Fetch ridge GIF from radar.weather.gov and convert to JPEG bytes.
    """
    try:
        logging.info(f"Fetching radar image: {url}")
        resp = requests.get(url, timeout=10)
        resp.raise_for_status()
        img = Image.open(BytesIO(resp.content)).convert("RGB")
        buf = BytesIO()
        img.save(buf, format='JPEG', quality=90)
        return buf.getvalue()
    except Exception as e:
        logging.error(f"RADAR ERROR: {url} | {e}")
        return make_placeholder_image("RADAR ERROR")


def generate_weather_frame() -> bytes:
    """
    Load weather_panel.png (generated by weather_panel_v0-1.py) and convert it to JPEG bytes.
    If missing or errors, return a placeholder.
    """
    if not os.path.exists(WEATHER_PANEL_PATH):
        logging.warning(f"Weather panel not found at {WEATHER_PANEL_PATH}")
        return make_placeholder_image("WEATHER PANEL MISSING")

    try:
        logging.info(f"Serving weather panel: {WEATHER_PANEL_PATH}")
        return image_path_to_jpeg_bytes(WEATHER_PANEL_PATH)
    except Exception as e:
        logging.error(f"WEATHER PANEL ERROR: {WEATHER_PANEL_PATH} | {e}")
        return make_placeholder_image("WEATHER ERROR")


# ======================================================================
#  SLIDESHOW PRODUCER
# ======================================================================
def generate_slideshow_images(directories, time_interval):
    """
    Core producer loop.

    Sequence per cycle:
      - Show IMAGE_COUNT_DISPLAY photo slides
      - Then show: TIME -> WEATHER -> RADAR 1 -> RADAR 2
      - Repeat.
    """
    duration = time_interval
    photo_counter = 0  # counts photos within the current IMAGE_COUNT_DISPLAY-photo block

    if not directories:
        logging.warning("No directories available at startup.")
        update_current_frame(make_placeholder_image("NO DIRECTORIES"), "[NO DIRECTORIES]")
    else:
        update_current_frame(make_placeholder_image("Starting slideshow..."), "[STARTUP]")

    while True:
        if not directories:
            logging.warning("No directories available for slideshow. Sleeping 5 seconds.")
            time.sleep(5)
            continue

        directory = random.choice(directories)
        logging.info(f"Selected directory: {directory}")

        image_files = []
        try:
            for file in os.listdir(directory):
                if file.lower().endswith(IMAGE_EXTENSIONS):
                    image_files.append(os.path.join(directory, file))
        except FileNotFoundError:
            logging.warning(f"Directory disappeared: {directory}")
            continue

        if not image_files:
            logging.warning(f"No images in directory: {directory}")
            continue

        random.shuffle(image_files)
        image_files = image_files[:IMAGES_PER_DIRECTORY]

        for image_path in image_files:
            # Show a photo
            update_current_frame(image_path_to_jpeg_bytes(image_path), image_path)
            time.sleep(duration)

            photo_counter += 1

            # After IMAGE_COUNT_DISPLAY photos, inject TIME + WEATHER + RADAR1 + RADAR2
            if photo_counter >= IMAGE_COUNT_DISPLAY:
                # TIME
                update_current_frame(generate_time_frame(), "[TIME]")
                time.sleep(duration)

                # WEATHER (from weather_panel.png)
                update_current_frame(generate_weather_frame(), "[WEATHER]")
                time.sleep(duration)

                # RADAR 1 then RADAR 2 (fixed order)
                for radar_url in RADAR_IMAGE_URLS:
                    update_current_frame(fetch_radar_frame(radar_url),
                                         f"[RADAR] {radar_url}")
                    time.sleep(duration)

                # Reset for next cycle of photos
                photo_counter = 0


# ======================================================================
#  MJPEG-CAPABLE HTTP HANDLER
# ======================================================================
class SlideshowHTTPRequestHandler(SimpleHTTPRequestHandler):

    def do_GET(self):
        if self.path == '/slideshow':
            html_page = self.get_html_content()     
            body_bytes = html_page.encode('utf-8')

            self.send_response(200)
            self.send_header('Content-Type', 'text/html; charset=utf-8')
            self.send_header('Content-Length', str(len(body_bytes)))
            self.send_header('Connection', 'close')
            self.end_headers()

            self.wfile.write(body_bytes)
            self.wfile.flush()
            self.close_connection = True
            return

        elif self.path == '/stream':
            self.handle_mjpeg_stream()

        elif self.path == '/favicon.ico':
            self.send_response(204)
            self.end_headers()

        else:
            self.send_error(404, "Not Found")


    def get_html_content(self):
        return '''
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Slideshow V2-1 MJPEG + RADAR + WEATHER</title>
            <style>
                html, body {
                    margin:0; padding:0; width:100%; height:100%;
                    background:#000; overflow:hidden;
                }
                body { display:flex; justify-content:center; align-items:center; }
                img { width:100vw; height:100vh; object-fit:contain; }
            </style>
        </head>
        <body>
            <img src="/stream" alt="Slideshow stream">
        </body>
        </html>
        '''.strip()

    def handle_mjpeg_stream(self):
        logging.info("MJPEG client connected")

        self.send_response(200)
        self.send_header('Content-type', 'multipart/x-mixed-replace; boundary=frame')
        self.send_header('Cache-Control', 'no-cache, no-store, must-revalidate')
        self.send_header('Pragma', 'no-cache')
        self.send_header('Expires', '0')
        self.end_headers()

        boundary = b"--frame\r\n"
        last_frame_id = -1

        try:
            while True:
                with frame_condition:
                    while current_frame_bytes is None or current_frame_id == last_frame_id:
                        frame_condition.wait()
                    frame = current_frame_bytes
                    fid = current_frame_id

                try:
                    self.wfile.write(boundary)
                    self.wfile.write(b"Content-Type: image/jpeg\r\n")
                    self.wfile.write(
                        b"Content-Length: " + str(len(frame)).encode('ascii') + b"\r\n\r\n"
                    )
                    self.wfile.write(frame)
                    self.wfile.write(b"\r\n")
                    self.wfile.flush()
                    last_frame_id = fid
                except (BrokenPipeError, ConnectionResetError):
                    # Restore V1-0 wording
                    logging.info("MJPEG client disconnected (Broken pipe / reset)")
                    break
        except Exception as e:
            logging.warning(f"MJPEG stream exception: {e}")


# ======================================================================
#  THREADED HTTP SERVER
# ======================================================================
class ThreadingHTTPServer(ThreadingMixIn, HTTPServer):
    daemon_threads = True


def load_directories(filepath):
    if not os.path.exists(filepath):
        logging.warning(f"File not found: {filepath}")
        return []
    with open(filepath) as f:
        return [line.strip().strip('"') for line in f if line.strip()]


def run_server(port=8000):
    httpd = ThreadingHTTPServer(('', port), SlideshowHTTPRequestHandler)

    context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    context.load_cert_chain(
        certfile="/home/superben/myProjects/python/slideshow/certs/hottub.crt",
        keyfile="/home/superben/myProjects/python/slideshow/certs/hottub.key"

    )
    httpd.socket = context.wrap_socket(httpd.socket, server_side=True)

    logging.info(f"Server on port {port} (V2-1 MJPEG + RADAR + WEATHER, threaded)")
    logging.info("Serving on https://0.0.0.0:8000/slideshow")
    httpd.serve_forever()

# ======================================================================
#  MAIN
# ======================================================================
if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Slideshow V2-1 â€” Recursive Photo Viewer with MJPEG push stream, weather panel, and radar.weather.gov ridge frames",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('preferred', nargs='?', help="Guest list: slideshowPreferred<NAME>.txt")
    args = parser.parse_args()

    if args.preferred:
        txt_path = os.path.join(PROJECT_DIR, f'slideshowPreferred{args.preferred}.txt')
    else:
        txt_path = os.path.join(PROJECT_DIR, 'slideshowDirectories.txt')

    starting_dirs = load_directories(txt_path)

    if not starting_dirs:
        print("Error: No starting directories found.")
        logging.error("No starting directories found. Exiting.")
        exit(1)

    # Recursive discovery of subdirectories (same as V1-0)
    directories = collect_image_directories(starting_dirs)

    threading.Thread(
        target=generate_slideshow_images,
        args=(directories, SLIDE_DURATION_SECONDS),
        daemon=True
    ).start()

    run_server()

